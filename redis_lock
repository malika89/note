#!/usr/bin/python
# coding:utf-8

from redis import Redis
import logging
import uuid
import time
from threading import Thread
import pymysql
import random


class RedisX(Redis):

    def __init__(self, host='localhost', port=6379, db=0, password=None, username=None, **kwargs):
        self.Locker = None
        super().__init__(host, port, db, password, username, **kwargs)

    # 查询被那个线程或者pid获取

    def set(self, k, value, expire):
        acquired = False
        while not acquired:
            acquired = self.acquire_lock(k)
            logging.info(f"key{k}is been used by others ")
            continue
        logging.info(f"get the key now !!!!:{k}")
        super().set(k, value, expire)
        self.release_lock(k, acquired)

    # 获取一个锁
    def acquire_lock(self, lock_name, acquire_time=10, timeout=10):
        identifier = str(uuid.UUID)
        end_time = time.time()+acquire_time
        lock = "lock:"+lock_name
        while time.time() <end_time:
            if self.setnx(lock, identifier):
                self.expire(lock, timeout)
                return identifier
            elif not self.ttl(lock):
                self.expire(lock, timeout)
            time.sleep(0.001)
        return False

    # 释放一个锁
    def release_lock(self, lock_name, identifier):
        lock = "lock:"+lock_name
        pipe = self.pipeline(True)
        while True:
            try:
                pipe.watch(lock)
                lock_value = self.get(lock)
                if not lock_value:
                    return True
                if lock_value.decode() == identifier:
                    pipe.multi()
                    pipe.delete(lock)
                    pipe.execute()
                    return True
                pipe.unwatch()
                break
            except Exception:
                pass
        return False


class ThreadWithReturnValue(Thread):
    def __init__(self, group=None, target=None, name=None,args=(), kwargs={}, Verbose=None):
        Thread.__init__(self, group, target, name, args, kwargs)
        self._return = None

    def run(self):
        if self._target is not None:
            self._return = self._target(*self._args, **self._kwargs)

    def join(self, *args):
        Thread.join(self, *args)
        return self._return


def deal_with_mysql(m):

    def deal_stock_db(n, user):
        db = pymysql.connect(host="10.25.72.208", port=3306, user="root", password="PACloud@20!^", database="test")
        cursor = db.cursor()
        db.begin()
        sql = 'select no from resource where name="ticket" for update'
        cursor.execute(sql)
        ret = cursor.fetchone()
        if ret[0] < n:
            cursor.close()
            db.close()
            return "no stock"
        try:
            update_sql = "update resource set no={} where name='ticket'".format(ret[0] - n)
            cursor.execute(update_sql)
            sql = 'insert into records(user,no) values("{}",{})'.format(user, n)
            cursor.execute(sql)
            db.commit()
        except Exception as e:
            print(e)
            pass
    start_time = time.time()
    for i in range(m):
        per_ticket = random.randint(1, 2)
        t = ThreadWithReturnValue(target=deal_stock_db, args=(per_ticket,f'user_{i}'))
        t.start()
    print("票已售完,耗时:", time.time()-start_time)



if __name__ == '__main__':
    # client = RedisX(host="10.25.72.208", port="6379", db=1, password="PACloud@20!^")
    totalNum = 30
    # 100个人抢30张票
    deal_with_mysql(100)

