#### 清除-标记法(before gp 1.3)：
  1. 暂停程序逻辑业务，找出所有可达的对象，并标记
  2. 清除未标记的对象
  3. 程序暂停取消，重复上述操作，直至程序生命周期结束
  
#### 三色标记法(since go1.5)

`**非分代、非移动、并发的、三色标记清除**`
  
  灰色：对象还在标记队列中等待
  黑色：对象已被标记，不会在本次gc中被清理
  白色：对象未被标记，将在本次gc中被清理
```
  step1: gc执行扫描中止，所有p到达GC安全点。
  step2 :全局变量和函数栈里的对象置为灰色 *slot = value
  step3 :将原灰色对象指向变量设置为灰色，灰色对象置为黑色
  GC 使用分布式终止算法来检测何时没有更多根标记作业或灰色对象
  step n : 并发清除白色对象(并发起goroutine)
```

  因为并发标记可能导致漏标，引入混合写屏障。
  
#### 混合写屏障(since go1.8)
  gc时间1ms
  产生的背景：栈上，寄存器对象的赋值（插入，删除）不能 hook ;由于三色标记是并发的，会导致漏标情形；仍然需要stw
  
  引入阶段 ：在GC的标记阶段启用，混合写屏障会同时标记指针写入目标的“原指针”和“新指针;
  
  引入后的效果：
```
   1.混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可；
   2.混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；
   3.混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW；
   4.混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作；
```
  

-----
#### 垃圾回收触发时机
  1) GOGC default 100(每当内存扩大一倍时启动GC) 如果达到阀值则立即启动 GC. 阀值 = 上次GC内存分配量 * 内存增长率
  2) 默认情况下，最长2分钟触发一次GC。
  3) 程序代码中也可以使用 runtime.GC() 来手动触发GC。这主要用于GC性能测试和统计。

#### GC优化：
  1) 设置GOGC
  2) 减少对象分配，使用内存复用
  3) 减少string和[]byte转换:底层数据会进行复制，导致gc效率低
  4) 推荐strings.join 而不是"+" 连接字符串(会生成新对象)


-----


#### 关于屏障：
    1. 内存屏障只是一段特殊代码，且在编译期间生成
	2. 在运行期间拦截内存写操作
	writePoint(slot,ptr){
	    shade(*slot)
		shade(ptr)
		*slot = ptr
	}		
		
#### 辅助GC(Mutator Assist)
为了防止内存分配过快，在 GC 执行过程中，如果 goroutine 需要分配内存，那么这个 goroutine 会参与一部分GC的工作

