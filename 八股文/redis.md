### 相关书籍
 + mysql45讲
 + 掘金小册-从根上理解MySQL

---
### B树
#### B+树

---
### 回表
  数据库根据索引（非主键）找到了指定的记录所在行后，还需要根据索引上保存的主键 ID 再次到数据块里获取数据
 「回表」一般就是指执行计划里显示的 「TABLE ACCESS BY INDEX ROWID」。
#### 避免回表：
 + 将需要的字段放在索引中去，查询的时候就能避免回表
 + 查询语句符合覆盖索引条件
 + 禁止select * 的原因，最主要是避免回表带来的随机io操作
#### 索引覆盖
覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取


---
### join 原理
#### 嵌套循环连接(Nested-Loop Join)
嵌套循环连接，驱动表作为第一层，被驱动表作为第二层.
时间复杂度为 count(驱动表的记录) x count(被驱动表)
```
for 驱动表的每行记录 in 驱动表的记录
    for 被驱动表每行记录 in 被驱动表的记录
        if (on条件（驱动表的每行记录，被驱动表的每行记录）？return true : false
```

#### join buffer
  + 解决join 全表扫描重复匹配问题：将驱动表结果一次性加载到join buffer，与被驱动表进行匹配查询
  + 时间复杂度：O(被驱动表n)
  + 使用join_buffer进行 缓冲：join buffer就是执行连接查询前申请的一块固定大小的内存，如果cache 满了则调用flush_cached_records
  + 使用场景/条件：被驱动表查询类型是ALL或者Index(全表扫描 没有索引 非等值连接)
   ##### 特点
   + mysql57 join buffer 使用在 块的嵌套循环连接（Block Nested-Loop Join）;mysql 8 用于hash join
   + 仅存储使用到的列，而不是整个行
   + join_buffer_size默认256K，推荐16M.越大，扫描的次数越少t3
   + Join Buffer在联接发生之前进行分配，在SQL语句执行完后进行释放
  

#### hash join
 

---
### 查询相关优化原理
#### 查询缓存
 + 读查询在开始之前必须先检查是否命中缓存。
 + 如果这个读查询可以被缓存，那么当完成执行后，MySQL若发现查询缓存中没有这个查询，会将其结果存入查询缓存，这会带来额外的系统消耗。
 + 这对写操作也会有影响，因为当想某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就可能会带来很大的系统消耗。
一般线上关闭查询缓存，mysql8.0已取消


#### order_by 排序 原理
 
排序分类： 
 + using filtersort
    + 排序时候，MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer
    + 整个的排序动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size
    + 外部排序使用归并排序算法

 + using index: 索引排序（排序字段使用索引）
    + 在排序字段有索引的情况下，查询过程不需要临时表，也不需要排序。 
    + 同时，也不会扫描全部符合条件的行数，而是找到适合条件既会返回数据
     + +  无条件查询如果只有order by create_time,即便create_time上有索引,也不会使用到。 因为优化器认为走二级索引再去回表成本比全表扫描排序更高。所以选择走全表扫描
     + +  无条件查询但是是order by create_time limit m.如果m值较小,是可以走索引的. 
          ```
          因为优化器认为根据索引有序性去回表查数据,然后得到m条数据,就可以终止循环,那么成本比全表扫描小,则选择走二级索引。`
          mysql针对order by limit也做了优化,采用堆排序
          ```
##### sort_buffer缓存
  + sort_buffer默认容量大小8M，最大16M
  + 单路排序算法：sort buffer 缓冲区缓存整个行的数据，在根据排序字段进行排序，返回数据给客户端，缺点：占用内存 优点：避免回表查询
  + 双路排序算法：sort buffer 缓冲区只缓存主键id和排序字段在内存中，在根据排序字段进行排序，在做一次回表查询，根据主键id查询该行数据返回给客户端

#### group by 原理
联合索引中用于group的字段必须符合索引的“最左前缀”原则
  + 松散索引： MySQL 完全利用索引扫描来实现 GROUP BY 的时候，并不需要扫描所有满足条件的索引键即可完成操作得出结果。
    ```
    ◆GROUP BY 条件字段需要符合最左前缀索引;
    ◆在使用GROUP BY 的同时，只能使用 MAX 和 MIN 这两个聚合函数;
    ◆如果引用到了该索引中 GROUP BY 条件之外的字段条件的时候，必须以常量形式存在;
    ```
  + 紧凑索引: 扫描索引的时候，读取所有满足条件的索引键，然后再根据读取的数据来完成 GROUP BY 操作,得到相应结果。
  + 临时表: ySQL Query Optimizer 无法找到合适的索引可以利用的时候，就不得不先读取需要的数据，然后通过临时表来完成 GROUP BY 操作

#### count的原理

##### count(*)
 + MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高；
 + InnoDB引擎执行count(*)的时候，需要把数据一行一行地从引擎里面读出来(不取值)，然后累积计数，效率较低
 + innoDB的事务设计：默认隔离级别是可重复读。只可以计算每个会话自己可见的行
##### count(1) 
nnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加
##### count(id)
innoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加

##### 大数据量count如何优化?
  + 主从，从采用myisam
 
---
### 表设计相关
#### 冷热分离
##### 使用场景：
   + 旧的数据不在会修改，也就是只有读没有写的情况下
   + 用户不在意老的数据，老的数据对用户来说没有什么用的情况下
#### 实现方式：
   + 监听数据库变更日志binlog+ 订阅canal的方式来触发
   + 定时任务：进行定时扫描热数据，进行冷热识别，之后同步到冷数据库里面
      + 缺点：无法实时||数据量较大耗时过多
      + 方案：多线程提高同步；数据表示flag=1


#### CQRS: 一种读写分离的数据处理模式
 + CQRS: 命令查询责任分离 （CQRS）体系结构
 + 基于事件的编程模型
 + DDD中使用


### 实际应用场景
#### case1
 数据量很大，而在某些热点数据冲击的情况下我们考虑到数据库性能和流量压力的情况下，将直接读库改为：
``` 
 1.分库表让不同数据库来接受请求，
 2将数据库索引字段减小并采用联合索引方式 
 3 设置了主从读写分离，路由分片机制让数据读写性能进一步提升，
 4为了应对可能的突增流量问题，设置了自动根据热度请求将数据缓存设为不过期以防止雪崩或击穿，
 5 通过canal订阅binlog来实现缓存数据同步业务的
```
#### case2优化方式
```

 1. 给order by 字段增加索引,orderby的字段必须在最前面设置
 应避免索引设置如下：
   使用select * 则不能利用覆盖索引扫描且由于where语句没有具体条件MySQL选择了全表扫描且进行了排序操作。
   当查询条件使用了与order by不同的索引，但排序字段是另一个联合索引的非连续部分
   返回数据量过大也会不使用索引
   order by 字段使用了表达式
2. 去掉不必要的返回字段
3. 增大 sort_buffer_size 参数设置
```


